# Studying records of database

## ACID

A：Atomicity(原子性)，C：Consistency（一致性），I：Isolation（独立性），D：Durability(持久性)

Isolation（level）:

1、read uncommitted

2、read committed

3、repeatable read

4、serializable(可串行化)

锁：

共享锁S（与共享锁兼容，与排他锁不兼容）, 排他锁X



在一个事务处理完前，提前释放可能会造成**脏读**，而延迟释放又可能造成**死锁**

可能出现死锁的情况：

> |    Lock A    |    Lock B    |
> | :----------: | :----------: |
> | do something | Lock A(等待) |
> | Lock B(等待) |              |
>
> 

## 封锁协议

​	目的：可串行化（避免环）

​	何时授予锁?

- 要解决的问题：饿死：有事务可能会一直等待：如一个表被一直加共享锁，排他锁会一直等待

- 1.与现存锁不冲突  2.无等待事务

  

  两阶段封锁协议：

  1. 增长阶段：只能加锁

  2. 释放阶段：只能解锁

     两阶段封锁协议并不能保证成环的问题

     严格两阶段封锁：解决级联回滚的问题：排他锁只在提交后才释放

     强两阶段封锁：在对某一表操作时，所有锁在提交之后才释放

锁升级与降级

​	升级只在增长阶段，降级只在释放阶段

防止死锁：

​	基于时间戳

 - 等待模式(时间顺序决定是等待还是回滚：新事务回滚，老事务等待)

 - 创伤等待（与普通等待模式相反）

   以上两种方法都可能造成回滚掉某一事务，如果采用**锁超时**机制，可以避免不必要的回滚。

   

死锁检测与恢复

 - 死锁检测

   等待图（检测是否有环）

 - 死锁恢复

   + 牺牲者（考虑代价）
   + 回滚（彻底回滚，部分回滚：只回滚到解除死锁的地方）
   + 饿死（有的事务可能总是成为牺牲者，可以在代价因素中考虑回滚次数）。

   

   多粒度

   时间戳

意向锁

​	意向排他及共享

意向共享锁（只锁一行共享锁？）

意向排他锁

乐观锁：两阶段加锁协议

悲观锁

## 时间戳协议

时间戳排序

- 可以防止死锁
- 可能出现饿死（长事务一直等待）：

满足满足两阶段封锁但不满足时间戳：

|   $T_1$   |      $T_2$       |
| :-------: | :--------------: |
| lock-s(A) |                  |
|           |    lock-s(A)     |
|  read(A)  |                  |
| unlock(A) |                  |
|           | upgrade(lock(A)) |
|           |     write(A)     |
|           |    unlock(A)     |

​	满足时间戳但不满足两阶段封锁：

### 有效性协议

### 多版本机制

## 恢复系统



数据库设计

查询